#include "rs485.h"
#include "stm32f10x.h"
#include <stdio.h>
#include "delay.h"
#include "iocheck.h"

// CRC 高位字节值表
static const unsigned char s_CRCHi[] = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
    0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
    0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
} ;
// CRC 低位字节值表
const unsigned char s_CRCLo[] = {
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
	0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
	0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
	0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
	0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
	0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
	0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
	0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
	0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
	0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
	0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
	0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
	0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
	0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
	0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
	0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

u8 Temp_str[50];
u8 count=0; 
u8 Temp_cmd[8]={0x01,0x03,0x00,0x00,0x00,0x02,0xC4,0x0B};		//PM2.5/PM10
u8 USART1_RX_BUF[USART1_REC_LEN];				 //接收缓冲,最大USART_REC_LEN个字节.
u8 USART1_TX_BUF[USART1_SEND_LEN]; 	//发送缓冲,最大USART2_MAX_SEND_LEN字节
u8 USART1_TX_CNT=0;
//通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据.
//如果2个字符接收间隔超过10ms,则认为不是1次连续数据.也就是超过10ms没有接收到
//任何数据,则表示此次接收完毕.
//接收到的数据状态
//[15]:0,没有接收到数据;1,接收到了一批数据.
//[14:0]:接收到的数据长度
u16 USART1_RX_STA=0;   	 
void USART1_IRQHandler(void)
{
	u8 res;	    
	if(USART1->SR&(1<<5))//接收到数据
	{	 
		res=USART1->DR; 			 
		if(USART1_RX_STA<USART1_REC_LEN)		//还可以接收数据
		{
			TIM4->CNT=0;         					//计数器清空
			if(USART1_RX_STA==0) time4_start();	 	//使能定时器4的中断 
			USART1_RX_BUF[USART1_RX_STA++]=res;		//记录接收到的值	 
		}else 
		{
			USART1_RX_STA|=1<<15;					//强制标记接收完成
		} 
	}  											 
}   


/************************************************************************************
* 函数名称：CRC16_Modbus
* 功能描述：自动CRC16校验
* 入口参数：_pBuf：参与校验数据
						_usLen：数据长度
* 出口参数：16位校验值
*************************************************************************************/
u16 CRC16_Modbus(u8 *_pBuf, int _usLen)
{
  char ucCRCHi = 0xFF; /* 高CRC字节初始化 */
	char ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
	int usIndex;  /* CRC循环中的索引 */

  while (_usLen--)
  {
		usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
		ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
		ucCRCLo = s_CRCLo[usIndex];
  }
    return ((u16)ucCRCHi << 8 | ucCRCLo);
}


void get_data(void)
{
	u16 pm25,pm10;
	USART1_SendDat(Temp_cmd, 8);
	delay_ms(100);
	if(USART1_RX_STA&0X8000)
	{
		if(CRC16_Modbus(USART1_RX_BUF,7)==(USART1_RX_BUF[7]<<8|USART1_RX_BUF[8]))  //判断CRC
		{
			pm25=USART1_RX_BUF[3]*256+USART1_RX_BUF[4];

			pm10=USART1_RX_BUF[5]*256+USART1_RX_BUF[6];
			sprintf((char*)Temp_str,"%d&%d&%d&%d&%d&%d&%d",pm25,pm10,FIFO1,FIFO2,FIFO3,FIFO4,FIFO5);
			//printf("Temp_str=%s\r\n",Temp_str);
		}
		USART1_RX_STA=0;
	}
	else
	{
		sprintf((char*)Temp_str,"_&_&%d&%d&%d&%d&%d",FIFO1,FIFO2,FIFO3,FIFO4,FIFO5);
		printf("sendcomandTemp\r\n");
	}
	delay_ms(50);
}


void uart1_init(u32 bound)
{
	//GPIO端口设置
	GPIO_InitTypeDef GPIO_InitStructure;
  USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);	//使能USART1，GPIOA时钟
	
	
	//USART1_TX   GPIOA.9
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9

	//USART1_RX	  GPIOA.10初始化
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  

	//USART 初始化设置
	USART_InitStructure.USART_BaudRate = bound;//串口波特率
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	//Usart1 NVIC 配置
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	
	 NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);

	USART_Init(USART1, &USART_InitStructure); //初始化串口1
	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
	USART_Cmd(USART1, ENABLE);                    //使能串口1 
	
	TIM4_Init(99,7199);		//10ms中断
	USART1_RX_STA=0;		//清零
	time4_stop();			//关闭定时器
}

/************************************************************************************
* 函数名称：UART4_SendByte
* 功能描述：UART4发送一个字符函数
* 入口参数：-dat:要发送的数据
* 出口参数：无
*************************************************************************************/
void USART1_SendByte(u8 dat)
{
	while(!(USART1->SR&(1<<6)));			//等待移位寄存器为空
	USART1->DR = dat;
}

/************************************************************************************
* 函数名称：UART_SendDat
* 功能描述：UART4发送len个字符函数
* 入口参数：-dat:要发送的数据 len:要发送数据的长度
* 出口参数：无
*************************************************************************************/
void USART1_SendDat(u8 *buf,u8 len)
{
	u8 i;
  for(i=0;i<len;i++)		//循环发送数据
	{
		while((USART1->SR&0X40)==0);//等待发送结束		  
		USART1->DR=buf[i];
	}	 
}

/************************************************************************************
* 函数名称：TIME4_Init
* 功能描述：TIME4初始化以及定时1s函数
* 入口参数：无
* 出口参数：无
*************************************************************************************/
void TIM4_Init(u16 psc,u16 arr)
{
	RCC->APB1ENR|=1<<2;	//TIM3时钟使能 
	TIM4->PSC=psc; //设置预分频系数
	TIM4->ARR=arr; //设置重装载值
	TIM4->CR1 |= 1<<7;//开启影子寄存器
	TIM4->EGR |= 1<<0; //设置UG位,软件更新
	TIM4->SR =~0X01;   //清标志
	TIM4->DIER |=1<<0; //开启定时器中断
	//设置NVIC
	NVIC_SetPriorityGrouping(7-2); //设置为分组2
	NVIC_SetPriority(TIM4_IRQn,NVIC_EncodePriority(7-2,2,2));//抢占优先级设置为,响应优先级为2
	NVIC_EnableIRQ(TIM4_IRQn);
}

/************************************************************************************
* 函数名称：time4_start
* 功能描述：定时器开始函数
* 入口参数：无
* 出口参数：无
*************************************************************************************/
void time4_start(void)
{
    //使能
    TIM4->CNT = 0;
    TIM4->CR1 |= (1<<0);    
}

/************************************************************************************
* 函数名称：time4_stop
* 功能描述 ：定时器停止函数
* 入口参数：无
* 出口参数：无
*************************************************************************************/
void time4_stop(void)
{
    TIM4->CR1 &= ~(1<<0);    
}

/************************************************************************************
* 函数名称：TIM4_IRQHandler
* 功能描述：TIME4更新中断函数
* 入口参数：无
* 出口参数：无
*************************************************************************************/
void TIM4_IRQHandler(void)
{
	if(TIM4->SR & 1<<0) //定时器3中断
	{
		USART1_RX_STA|=1<<15;	//标记接收完成
		TIM4->SR &= ~(1<<0); //清标志
		time4_stop();				//关闭定时器
	}
}

